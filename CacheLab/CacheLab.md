# Part B

## 32x32
第一个测试矩阵大小是 32 x 32 的。我们先来分析一下，一个 int 类型数字是 4 字节，cache 中一行 32 字节，可以放 8 个 int 。

可以发现，A 和 B 中相同位置的元素（对角线）是映射在同一cache line 上的，譬如我们已经把 A 的第四行存进去了，但是当要写 B[4][4] 时，发生了冲突，第四行被换成 B 的，然后读 A 的时候又换成了 A 的，就多造成了两次 miss。

因为除了循环需要的 4 个变量外我们还剩余 8 个自由变量可以用，正好可以存一个 cache line。以空间换时间，把一行一次性读完，减少冲突不命中。

![1](./assets/1.png)

现在是288次，哪里出现了问题？现在A是在每对8个int 操作时，会不命中一次，即每个块中有且只有一个元素不被命中，这是无法避免的，而 B 现在是不仅在开头有不命中，在对角线上也有不命中，如果能把 B 中的对角线元素命中的话，就可以达到理论上的 256 次 miss。这里不继续优化了。

## 64x64
对 64 x 64 的矩阵来说，每行有 64 个 int，则 cache 只能存矩阵的 4 行了，所以如果使用 8x8 的分块，一定会在写 B 的时候造成冲突，因为映射到了相同的块。

还是考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：
- 第一步，将A的左上和右上一次性复制给B
- 第二步，用本地变量把B的右上角存储下来
- 第三步，将A的左下复制给B的右上
- 第四步，利用上述存储B的右上角的本地变量，把A的右上复制给B的左下
- 第五步，把A的右下复制给B的右下


## 61x67
直接8x8，不再赘述





